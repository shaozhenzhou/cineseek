# CineSeek 详细设计说明书

## 文档信息

| 项目名称 | CineSeek - 电影信息搜索系统 |
|---------|---------------------------|
| 文档版本 | 1.0 |
| 编写日期 | 2025-11-02 |
| 编写人 | 开发团队 |
| 审核人 | 项目负责人 |

## 1. 引言

### 1.1 编写目的

本文档详细描述 CineSeek 系统各模块的内部设计,包括类设计、函数设计、算法设计等,为开发人员提供实现指导。

### 1.2 参考资料

- CineSeek 概要设计说明书 v1.0
- CineSeek 需求规格说明书 v1.0
- Python PEP 8 编码规范
- Vue 3 Composition API 文档

## 2. 后端模块详细设计

### 2.1 解析器模块(parser.py)

#### 2.1.1 模块概述

解析器模块负责从复杂的电影文件名中提取核心电影名称和年份信息。

#### 2.1.2 常量定义

```python
# 常见噪声标记集合
_NOISE_TOKENS = {
    "1080p", "2160p", "720p", "480p", "4k", "8k",
    "webrip", "web-dl", "webdl", "hdr", "hdr10", "dv", "dolby", "vision",
    "x264", "x265", "h264", "h265", "hevc", "avc",
    "bluray", "bdrip", "brrip", "remux", "dvdrip",
    "dts", "dts-hd", "truehd", "atmos", "aac", "flac", "mp3",
    "dual", "audio", "multi", "subs", "multisub",
    "nf", "netflix", "imax", "remastered", "extended", "theatrical",
    "publichd", "eam", "protonmovies", "phdteam",
}

# 分隔符正则表达式
_SPLIT_PAT = re.compile(r"[\._\-\[\]\(\)\{\}（）【】《》\s]+", re.IGNORECASE)

# 年份匹配正则表达式
_YEAR_PAT = re.compile(r"(?P<year>19\d{2}|20\d{2})")

# 括号内容匹配正则表达式
_BRACKET_CONTENT = re.compile(r"[（\(]([^）\)]+)[）\)]")
```

#### 2.1.3 核心函数设计

**函数名**: `parse_title`

**功能**: 解析电影文件名,提取片名和年份

**函数签名**:
```python
def parse_title(raw: str) -> Tuple[str, Optional[int]]
```

**参数**:
- `raw` (str): 原始文件名字符串

**返回值**:
- `Tuple[str, Optional[int]]`: (清洗后的片名, 年份或None)

**算法流程**:

```
1. 输入预处理
   ├─ 去除首尾空白
   ├─ 检测年份紧密连接情况
   └─ 在年份前添加空格

2. 括号处理
   ├─ 提取括号内的年份
   └─ 移除所有括号内容

3. 尝试 guessit 解析
   ├─ 如果 guessit 可用
   │  ├─ 调用 guessit() 函数
   │  ├─ 提取 title 和 year
   │  └─ 如果成功,返回结果
   └─ 如果失败,继续下一步

4. 降级到正则解析
   ├─ 提取年份(如括号中未找到)
   ├─ 移除年份字符串
   ├─ 使用分隔符切分
   ├─ 过滤噪声标记
   ├─ 过滤纯数字
   └─ 合并剩余token

5. 返回结果
   └─ (片名, 年份)
```

**详细实现逻辑**:

1. **年份紧密连接处理**:
```python
year_match_direct = _YEAR_PAT.search(s)
if year_match_direct:
    year_pos = year_match_direct.start()
    if year_pos > 0 and not s[year_pos - 1].isspace():
        # 在年份前添加空格
        s = s[:year_pos] + ' ' + s[year_pos:]
```

2. **括号内年份提取**:
```python
bracket_matches = _BRACKET_CONTENT.findall(s)
for content in bracket_matches:
    year_match = _YEAR_PAT.search(content)
    if year_match:
        y = int(year_match.group("year"))
        if 1900 <= y <= 2100:
            year_from_bracket = y
            break
```

3. **guessit 解析**:
```python
if guessit is not None:
    try:
        g = guessit(s_no_brackets)
        title = g.get("title")
        year = g.get("year")
        if year_from_bracket:
            year = year_from_bracket
        if title:
            return title.strip(), year
    except Exception:
        pass  # 降级到正则解析
```

4. **正则解析**:
```python
# 提取年份
m = _YEAR_PAT.search(s_no_brackets)
if m:
    y = int(m.group("year"))
    if 1900 <= y <= 2100:
        year = y

# 移除年份
s_no_year = _YEAR_PAT.sub("", s_no_brackets).strip()

# 切分并清洗
tokens = [t for t in _SPLIT_PAT.split(s_no_year) if t]
cleaned = []
for t in tokens:
    tt = t.lower()
    if tt in _NOISE_TOKENS or tt.isdigit():
        continue
    cleaned.append(t)

# 合并
cleaned_name = " ".join(cleaned).strip()
return cleaned_name, year
```

**异常处理**:
- guessit 不可用或抛出异常:自动降级到正则解析
- 无法解析出片名:返回处理后的原始字符串
- 年份不合法:year 返回 None

**测试用例**:

| 输入 | 预期输出 |
|-----|---------|
| `White.House.Down.2013.1080p.BluRay.x264` | `("White House Down", 2013)` |
| `变形金刚2007.1080p.BluRay.x264` | `("变形金刚", 2007)` |
| `我是传奇(蓝光).I.Am.Legend.2007.HDR` | `("我是传奇" or "I Am Legend", 2007)` |
| `Inception.2010.IMAX.2160p.x265` | `("Inception", 2010)` |
| `阿凡达 (2009)` | `("阿凡达", 2009)` |

### 2.2 数据模型模块(models.py)

#### 2.2.1 模块概述

使用 Pydantic 定义数据模型,提供数据验证和序列化。

#### 2.2.2 SearchRequest 类

```python
class SearchRequest(BaseModel):
    """API 搜索请求模型"""
    query: str = Field(..., description="用户输入的模糊文件名或片名")
```

**字段说明**:
- `query`: 必填,搜索关键词

**验证规则**:
- 由 Pydantic 自动验证非空

#### 2.2.3 MovieResult 类

```python
class MovieResult(BaseModel):
    """电影搜索结果 - 兼容 douban.py 返回格式"""
    fullname: str = Field("", description="完整名称")
    name: str = Field("", description="中文名称")
    originalName: str = Field("", description="原始名称(英文名)")
    year: int = Field(0, description="年份")
    genre: str = Field("", description="类型")
    country: str = Field("", description="制片国家/地区")
    alias: str = Field("", description="又名")
```

**字段说明**:
- `fullname`: 中英文组合的完整名称
- `name`: 中文名称
- `originalName`: 英文原名
- `year`: 上映年份
- `genre`: 类型,逗号分隔
- `country`: 国家/地区,逗号分隔
- `alias`: 别名,逗号分隔

**默认值**: 所有字段都有默认值,避免必填导致的验证失败

#### 2.2.4 MovieResultExtended 类

```python
class MovieResultExtended(BaseModel):
    """电影搜索结果扩展版 - 为前端提供更多信息"""
    wikidata_id: Optional[str] = Field(None, description="Wikidata 条目 ID")
    title_cn: Optional[str] = Field(None, description="中文标题")
    title_en: Optional[str] = Field(None, description="英文标题")
    year: Optional[int] = Field(None, description="年份")
    display_title: str = Field(..., description="用于显示的组合标题")
    genres: List[str] = Field(default_factory=list, description="类型标签列表")
    countries: List[str] = Field(default_factory=list, description="制片国家/地区")
    poster_url: Optional[str] = Field(None, description="海报图片 URL")
    wikipedia_links: Dict[str, str] = Field(default_factory=dict, description="维基百科词条链接")
```

**字段说明**:
- `wikidata_id`: Wikidata ID,如 "Q25188"
- `title_cn`: 中文标题
- `title_en`: 英文标题
- `year`: 年份
- `display_title`: 显示标题,格式为 "{中文} {英文} ({年份})"
- `genres`: 类型列表,如 ["科幻", "动作"]
- `countries`: 国家列表,如 ["美国", "英国"]
- `poster_url`: 海报图片完整 URL
- `wikipedia_links`: 字典,键为语言代码(zh/en),值为 URL

**构造示例**:
```python
movie = MovieResultExtended(
    wikidata_id="Q25188",
    title_cn="盗梦空间",
    title_en="Inception",
    year=2010,
    display_title="盗梦空间 Inception (2010)",
    genres=["科幻", "动作", "惊悚"],
    countries=["美国", "英国"],
    poster_url="https://commons.wikimedia.org/...",
    wikipedia_links={
        "zh": "https://zh.wikipedia.org/wiki/盗梦空间",
        "en": "https://en.wikipedia.org/wiki/Inception"
    }
)
```

### 2.3 API 模块(api.py)

#### 2.3.1 模块概述

提供 RESTful API 接口,是前端与后端的通信桥梁。

#### 2.3.2 应用初始化

```python
app = FastAPI(title="CineSeek API", version="0.1.0")

# CORS 中间件配置
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # 开发环境
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

**配置说明**:
- `title`: API 文档标题
- `version`: API 版本号
- `allow_origins`: CORS 允许的源,生产环境应限制为具体域名

#### 2.3.3 路由处理函数

**1. 首页路由**

```python
@app.get("/")
@app.get("/index")
def index():
    """首页路由处理函数"""
    return "<html><body>Hello, This is CineSeek!</body></html>"
```

**说明**: 简单的欢迎页面

**2. 健康检查**

```python
@app.get("/api/health")
def health() -> dict:
    """健康检查"""
    return {"ok": True}
```

**说明**: 用于监控系统状态

**3. 兼容搜索接口**

```python
@app.get("/search")
async def search(keyword: str):
    """电影搜索接口:解析标题后到 Wikidata 检索"""
    # 1. 解析文件名
    name, year = parse_title(keyword)
    
    # 2. 搜索电影
    results = await search_movies(name, limit=10, extended=False)
    
    # 3. 年份过滤
    if year is not None:
        filtered = [r for r in results if r.year and abs(r.year - year) <= 1]
        if filtered:
            results = filtered
        results.sort(key=lambda r: abs((r.year or 0) - year) if r.year else 999)
    
    # 4. 返回第一个结果
    if not results:
        return ""
    
    return JSONResponse(
        content=results[0].dict(),
        headers={"Content-Type": "application/json; charset=utf-8"}
    )
```

**流程**:
1. 解析关键词
2. 搜索电影(最多10个)
3. 如有年份,进行过滤和排序
4. 返回最佳匹配结果

**4. 前端搜索接口**

```python
@app.post("/api/search", response_model=list[MovieResultExtended])
async def api_search(req: SearchRequest):
    """前端专用电影搜索接口:返回扩展信息"""
    # 1. 解析查询
    name, year = parse_title(req.query)
    
    # 2. 搜索电影(扩展模式)
    results = await search_movies(name, limit=10, extended=True)
    
    # 3. 年份过滤
    if year is not None:
        filtered = [r for r in results if r.year and abs(r.year - year) <= 1]
        if filtered:
            results = filtered
        results.sort(key=lambda r: abs((r.year or 0) - year) if r.year else 999)
    
    # 4. 限制返回数量
    results = results[:5]
    
    return JSONResponse(
        content=[result.dict() for result in results],
        headers={"Content-Type": "application/json; charset=utf-8"}
    )
```

**流程**:
1. 解析查询
2. 搜索电影(扩展模式,最多10个)
3. 年份过滤和排序
4. 限制返回5个结果
5. 返回 JSON 数组

**年份过滤算法**:
```python
# 允许 ±1 年误差
filtered = [r for r in results if r.year and abs(r.year - year) <= 1]

# 如果有匹配的,仅保留匹配的
if filtered:
    results = filtered

# 按年份差异排序
results.sort(key=lambda r: abs((r.year or 0) - year) if r.year else 999)
```

### 2.4 数据提供者模块(providers/wikidata.py)

#### 2.4.1 模块概述

负责与 Wikidata SPARQL 服务交互,执行电影信息查询。

#### 2.4.2 核心函数设计

**函数名**: `search_movies`

**功能**: 在 Wikidata 中搜索电影信息

**函数签名**:
```python
async def search_movies(
    title: str,
    limit: int = 10,
    extended: bool = False
) -> List[Union[MovieResult, MovieResultExtended]]
```

**参数**:
- `title`: 电影标题
- `limit`: 返回结果数量限制
- `extended`: 是否返回扩展信息

**返回值**:
- 基础模式: `List[MovieResult]`
- 扩展模式: `List[MovieResultExtended]`

**算法流程**:

```
1. 繁简转换
   ├─ 使用 OpenCC 转换为繁体
   └─ 同时搜索简体和繁体

2. 构建 SPARQL 查询
   ├─ 搜索中文标题(简体和繁体)
   ├─ 搜索英文标题
   ├─ 搜索别名
   ├─ 获取年份、类型、国家
   └─ 如果 extended=True,获取海报和维基链接

3. 执行 SPARQL 查询
   ├─ 使用 httpx 异步客户端
   ├─ 设置超时时间(15秒)
   └─ 处理网络错误

4. 解析响应
   ├─ 提取 bindings 数组
   ├─ 去重(按 wikidata_id)
   └─ 格式化为 MovieResult 或 MovieResultExtended

5. 返回结果列表
```

**SPARQL 查询模板**:

```sparql
SELECT DISTINCT ?item ?itemLabel ?year ?titleCN ?titleEN ?genre ?country
WHERE {
  ?item wdt:P31 wd:Q11424 .  # 实例是电影
  
  # 搜索中文标题(简体或繁体)
  {
    ?item rdfs:label ?titleCN .
    FILTER(LANG(?titleCN) = "zh" && 
           (REGEX(?titleCN, "{title_simp}", "i") || REGEX(?titleCN, "{title_trad}", "i")))
  }
  UNION
  # 搜索英文标题
  {
    ?item rdfs:label ?titleEN .
    FILTER(LANG(?titleEN) = "en" && REGEX(?titleEN, "{title}", "i"))
  }
  UNION
  # 搜索别名
  {
    ?item skos:altLabel ?alias .
    FILTER(REGEX(?alias, "{title}", "i"))
  }
  
  # 获取年份
  OPTIONAL { 
    ?item wdt:P577 ?publicationDate .
    BIND(YEAR(?publicationDate) AS ?year)
  }
  
  # 获取类型
  OPTIONAL {
    ?item wdt:P136 ?genreItem .
    ?genreItem rdfs:label ?genreLabel .
    FILTER(LANG(?genreLabel) IN ("zh", "en"))
  }
  
  # 获取国家
  OPTIONAL {
    ?item wdt:P495 ?countryItem .
    ?countryItem rdfs:label ?countryLabel .
    FILTER(LANG(?countryLabel) IN ("zh", "en"))
  }
  
  SERVICE wikibase:label { bd:serviceParam wikibase:language "zh,en" . }
}
LIMIT {limit}
```

**扩展信息获取**:

如果 `extended=True`,额外获取:

1. **海报 URL**:
```python
# 从 Wikidata P18 属性获取
poster_filename = binding.get("poster", {}).get("value")
if poster_filename:
    # 转换为 Wikimedia Commons URL
    poster_url = get_commons_url(poster_filename)
```

2. **维基百科链接**:
```python
wikipedia_links = {}
if wikidata_id:
    # 中文维基
    zh_link = f"https://zh.wikipedia.org/wiki/{quote(title_cn)}"
    wikipedia_links["zh"] = zh_link
    
    # 英文维基
    en_link = f"https://en.wikipedia.org/wiki/{quote(title_en)}"
    wikipedia_links["en"] = en_link
```

**错误处理**:
```python
try:
    response = await client.get(SPARQL_ENDPOINT, params=params, timeout=15.0)
    response.raise_for_status()
except httpx.TimeoutException:
    # 超时返回空列表
    return []
except httpx.HTTPError as e:
    # 网络错误返回空列表
    logger.error(f"HTTP error: {e}")
    return []
```

**去重逻辑**:
```python
seen = set()
unique_results = []
for result in results:
    if result.wikidata_id not in seen:
        seen.add(result.wikidata_id)
        unique_results.append(result)
```

## 3. 前端模块详细设计

### 3.1 主组件(App.vue)

#### 3.1.1 数据状态设计

```javascript
// 响应式状态
const q = ref('')                    // 搜索关键词
const loading = ref(false)           // 加载状态
const results = ref([])              // 搜索结果数组
const error = ref('')                // 错误信息
const showHistory = ref(false)       // 是否显示历史面板
const searchHistory = ref([])        // 搜索历史数组
```

**状态说明**:
- `q`: 与输入框双向绑定
- `loading`: 控制按钮禁用状态
- `results`: 存储 MovieResultExtended 对象数组
- `error`: 显示错误提示
- `showHistory`: 控制历史面板显示/隐藏
- `searchHistory`: 存储历史搜索词(最多10条)

#### 3.1.2 核心函数设计

**1. 搜索函数**

```javascript
async function doSearch() {
  error.value = ''
  results.value = []
  const text = q.value.trim()
  if (!text) return
  
  showHistory.value = false
  loading.value = true
  
  try {
    const r = await fetch(`${API_BASE}/api/search`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ query: text }),
    })
    
    if (!r.ok) {
      throw new Error(`服务错误:${r.status}`)
    }
    
    const data = await r.json()
    results.value = Array.isArray(data) ? data : []
    
    // 搜索成功后添加到历史
    if (results.value.length > 0) {
      addToHistory(text)
    }
  } catch (e) {
    error.value = e?.message || '网络错误'
  } finally {
    loading.value = false
  }
}
```

**流程**:
1. 清空错误和结果
2. 验证输入非空
3. 关闭历史面板
4. 设置加载状态
5. 发送 POST 请求
6. 处理响应
7. 添加到历史(成功时)
8. 错误处理
9. 恢复加载状态

**2. 历史管理函数**

```javascript
// 从 localStorage 加载历史
function loadHistory() {
  try {
    const saved = localStorage.getItem(HISTORY_KEY)
    if (saved) {
      searchHistory.value = JSON.parse(saved)
    }
  } catch (e) {
    console.error('加载历史记录失败', e)
  }
}

// 保存历史到 localStorage
function saveHistory() {
  try {
    localStorage.setItem(HISTORY_KEY, JSON.stringify(searchHistory.value))
  } catch (e) {
    console.error('保存历史记录失败', e)
  }
}

// 添加搜索记录(不重复)
function addToHistory(query) {
  const trimmed = query.trim()
  if (!trimmed) return
  
  // 移除已存在的相同记录
  const index = searchHistory.value.indexOf(trimmed)
  if (index > -1) {
    searchHistory.value.splice(index, 1)
  }
  
  // 添加到开头
  searchHistory.value.unshift(trimmed)
  
  // 限制最大数量
  if (searchHistory.value.length > MAX_HISTORY) {
    searchHistory.value = searchHistory.value.slice(0, MAX_HISTORY)
  }
  
  saveHistory()
}

// 清除所有历史记录
function clearHistory() {
  searchHistory.value = []
  saveHistory()
  showHistory.value = false
}

// 选择历史记录
function selectHistory(item) {
  q.value = item
  showHistory.value = false
  doSearch()
}
```

**设计要点**:
- 使用 localStorage 持久化
- 去重逻辑:先移除再添加到开头
- 最多保存10条
- 提供清除和选择功能

**3. 事件处理**

```javascript
// 点击外部关闭历史面板
function handleClickOutside(event) {
  const historyPanel = document.querySelector('.history-panel')
  const searchInput = document.querySelector('.input')
  if (historyPanel && !historyPanel.contains(event.target) && 
      !searchInput.contains(event.target)) {
    showHistory.value = false
  }
}

// 组件挂载时
onMounted(() => {
  loadHistory()
  document.addEventListener('click', handleClickOutside)
})
```

#### 3.1.3 模板设计

```vue
<template>
  <div class="container">
    <!-- 顶部标题 -->
    <div class="header">
      <div class="title">CineSeek</div>
      <div class="subtitle">电影信息搜索 · 基于 Wikidata/Wikipedia</div>
    </div>

    <!-- 搜索区 -->
    <div class="search">
      <input
        v-model.trim="q"
        @keyup.enter="doSearch"
        @focus="showHistory = true"
        placeholder="输入电影文件名..."
      />
      <button :disabled="loading || !q" @click="doSearch">搜索</button>
      
      <!-- 历史面板 -->
      <div v-if="showHistory && searchHistory.length > 0" class="history-panel">
        <div class="history-header">
          <span>搜索历史</span>
          <button @click="clearHistory">清除</button>
        </div>
        <div v-for="item in searchHistory" :key="item" @click="selectHistory(item)">
          {{ item }}
        </div>
      </div>
    </div>

    <!-- 错误提示 -->
    <div v-if="error" class="error">{{ error }}</div>

    <!-- 结果展示 -->
    <div v-if="results.length" class="grid">
      <div v-for="m in results" :key="m.wikidata_id" class="card">
        <img :src="m.poster_url || placeholderImg" :alt="m.display_title" />
        <div class="card-body">
          <div class="card-title">{{ m.display_title }}</div>
          <div><span v-for="g in m.genres" class="badge">{{ g }}</span></div>
          <div><span v-for="c in m.countries" class="badge">{{ c }}</span></div>
          <div>
            <a v-if="m.wikipedia_links?.zh" :href="m.wikipedia_links.zh">中文维基</a>
            <a v-if="m.wikipedia_links?.en" :href="m.wikipedia_links.en">英文维基</a>
          </div>
        </div>
      </div>
    </div>

    <!-- 底部 -->
    <div class="footer">© 2025 CineSeek</div>
  </div>
</template>
```

**设计要点**:
- 使用 `v-model.trim` 自动去除空白
- 使用 `@keyup.enter` 支持回车搜索
- 使用 `v-if` 条件渲染
- 使用 `v-for` 循环渲染
- 使用 `:disabled` 动态禁用按钮
- 使用懒加载 `loading="lazy"` 优化图片

## 4. 算法设计

### 4.1 年份过滤算法

**算法名称**: 年份匹配过滤与排序

**输入**:
- `results`: 搜索结果列表
- `target_year`: 目标年份

**输出**: 过滤和排序后的结果列表

**算法步骤**:

```python
def filter_by_year(results, target_year):
    # 步骤1: 过滤年份匹配的结果(允许±1年误差)
    filtered = [
        r for r in results 
        if r.year and abs(r.year - target_year) <= 1
    ]
    
    # 步骤2: 如果有匹配的,仅保留匹配的
    if filtered:
        results = filtered
    
    # 步骤3: 按年份差异排序
    results.sort(
        key=lambda r: abs((r.year or 0) - target_year) if r.year else 999
    )
    
    return results
```

**时间复杂度**: O(n log n),由排序决定

**空间复杂度**: O(n),需要存储过滤后的列表

**测试用例**:

| 输入年份 | 结果年份列表 | 预期输出 |
|---------|------------|---------|
| 2010 | [2010, 2009, 2011, 2008, 2012] | [2010, 2009, 2011] |
| 2010 | [2008, 2012, 2015] | [2008, 2012, 2015] (保留所有) |
| 2010 | [2010, 2010, 2009, 2011] | [2010, 2010, 2009, 2011] |

### 4.2 历史去重算法

**算法名称**: 搜索历史去重与置顶

**输入**:
- `history`: 历史记录列表
- `new_item`: 新搜索词

**输出**: 更新后的历史列表

**算法步骤**:

```javascript
function addToHistoryNoDup(history, new_item) {
    // 步骤1: 查找是否已存在
    const index = history.indexOf(new_item)
    
    // 步骤2: 如果存在,移除
    if (index > -1) {
        history.splice(index, 1)
    }
    
    // 步骤3: 添加到开头
    history.unshift(new_item)
    
    // 步骤4: 限制最大长度
    if (history.length > MAX_HISTORY) {
        history = history.slice(0, MAX_HISTORY)
    }
    
    return history
}
```

**时间复杂度**: O(n),由 indexOf 决定

**空间复杂度**: O(1),原地修改

## 5. 附录

### 5.1 代码规范

- **Python**: 遵循 PEP 8
- **JavaScript**: 遵循 Vue 3 Composition API 风格
- **注释**: 关键逻辑添加注释
- **命名**: 使用描述性名称

### 5.2 性能优化建议

1. 使用异步 I/O(httpx、async/await)
2. 前端懒加载图片
3. localStorage 持久化减少网络请求
4. 限制搜索结果数量

---

**文档状态**: ✅ 已完成  
**最后更新**: 2025-11-02  
**版本历史**: v1.0 - 初始版本
